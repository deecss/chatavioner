#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Generator podrƒôcznika ATPL
Automatyczne tworzenie podrƒôcznika na podstawie dostƒôpnych dokument√≥w i AI
"""

import os
import json
import uuid
from datetime import datetime
from typing import Dict, List, Any, Optional
import PyPDF2
import fitz  # PyMuPDF dla lepszego OCR
from openai import OpenAI
import re


class ATPLHandbookGenerator:
    """Generator podrƒôcznika ATPL na podstawie dostƒôpnych dokument√≥w"""
    
    def __init__(self):
        self.client = OpenAI()
        self.handbook_dir = 'handbook'
        self.program_file = None
        self.handbook_structure = {}
        self.progress_file = os.path.join(self.handbook_dir, 'progress.json')
        
        # Utw√≥rz katalog na podrƒôcznik
        os.makedirs(self.handbook_dir, exist_ok=True)
        
        # Za≈Çaduj postƒôp je≈õli istnieje
        self.load_progress()
    
    def find_program_file(self) -> Optional[str]:
        """Znajd≈∫ plik z programem ATPL"""
        uploads_dir = 'uploads'
        if not os.path.exists(uploads_dir):
            return None
        
        for filename in os.listdir(uploads_dir):
            if 'Program_ATPL-ang_serwis' in filename and filename.endswith('.pdf'):
                self.program_file = os.path.join(uploads_dir, filename)
                return self.program_file
        
        return None
    
    def extract_text_from_pdf(self, pdf_path: str) -> str:
        """WyciƒÖgnij tekst z PDF u≈ºywajƒÖc PyMuPDF (lepsze OCR)"""
        try:
            doc = fitz.open(pdf_path)
            text = ""
            
            for page_num in range(len(doc)):
                page = doc.load_page(page_num)
                text += page.get_text()
            
            doc.close()
            return text
        except Exception as e:
            print(f"‚ùå B≈ÇƒÖd wyciƒÖgania tekstu z PDF: {e}")
            # Fallback do PyPDF2
            return self._extract_text_pypdf2(pdf_path)
    
    def _extract_text_pypdf2(self, pdf_path: str) -> str:
        """Fallback - wyciƒÖgnij tekst u≈ºywajƒÖc PyPDF2"""
        try:
            with open(pdf_path, 'rb') as file:
                pdf_reader = PyPDF2.PdfReader(file)
                text = ""
                
                for page in pdf_reader.pages:
                    text += page.extract_text()
                
                return text
        except Exception as e:
            print(f"‚ùå B≈ÇƒÖd PyPDF2: {e}")
            return ""
    
    def analyze_program_structure(self) -> Dict[str, Any]:
        """Analizuj strukturƒô programu ATPL u≈ºywajƒÖc AI"""
        if not self.program_file:
            if not self.find_program_file():
                raise Exception("Nie znaleziono pliku z programem ATPL")
        
        print(f"üìÑ Analizujƒô strukturƒô programu: {self.program_file}")
        
        # WyciƒÖgnij tekst z PDF
        program_text = self.extract_text_from_pdf(self.program_file)
        
        if not program_text.strip():
            raise Exception("Nie uda≈Ço siƒô wyciƒÖgnƒÖƒá tekstu z pliku programu")
        
        # U≈ºyj AI do analizy struktury
        try:
            response = self.client.chat.completions.create(
                model="gpt-4",
                messages=[
                    {
                        "role": "system",
                        "content": """Jeste≈õ ekspertem od lotnictwa i analizy dokument√≥w szkoleniowych ATPL.
                        Przeanalizuj podany tekst programu szkolenia ATPL i wyciƒÖgnij strukturƒô kursu.
                        
                        Zwr√≥ƒá odpowied≈∫ w formacie JSON z nastƒôpujƒÖcƒÖ strukturƒÖ:
                        {
                            "title": "Tytu≈Ç programu",
                            "description": "Opis programu",
                            "total_hours": "≈ÅƒÖczna liczba godzin",
                            "modules": [
                                {
                                    "id": "module_1",
                                    "title": "Tytu≈Ç modu≈Çu",
                                    "description": "Opis modu≈Çu",
                                    "hours": "Liczba godzin",
                                    "chapters": [
                                        {
                                            "id": "chapter_1_1",
                                            "title": "Tytu≈Ç rozdzia≈Çu",
                                            "description": "Opis rozdzia≈Çu",
                                            "topics": [
                                                {
                                                    "id": "topic_1_1_1",
                                                    "title": "Tytu≈Ç tematu",
                                                    "description": "Opis tematu",
                                                    "subtopics": ["podtemat 1", "podtemat 2"]
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ]
                        }
                        
                        Zachowaj wszystkie szczeg√≥≈Çy i hierarchiƒô jak w oryginalnym dokumencie.
                        U≈ºywaj polskich nazw dla czƒô≈õci po polsku i angielskich dla czƒô≈õci w jƒôzyku angielskim."""
                    },
                    {
                        "role": "user",
                        "content": f"Przeanalizuj nastƒôpujƒÖcy tekst programu szkolenia ATPL:\n\n{program_text[:15000]}"  # Ograniczenie dla API
                    }
                ],
                temperature=0.3
            )
            
            structure_text = response.choices[0].message.content
            
            # WyciƒÖgnij JSON z odpowiedzi
            json_match = re.search(r'\{.*\}', structure_text, re.DOTALL)
            if json_match:
                structure = json.loads(json_match.group())
            else:
                # Spr√≥buj sparsowaƒá ca≈ÇƒÖ odpowied≈∫ jako JSON
                structure = json.loads(structure_text)
            
            # Zapisz strukturƒô
            self.handbook_structure = structure
            self.save_progress()
            
            print(f"‚úÖ Struktura programu przeanalizowana: {len(structure.get('modules', []))} modu≈Ç√≥w")
            return structure
            
        except Exception as e:
            print(f"‚ùå B≈ÇƒÖd analizy struktury: {e}")
            raise e
    
    def get_handbook_structure(self) -> Dict[str, Any]:
        """Pobierz strukturƒô podrƒôcznika"""
        if not self.handbook_structure:
            return self.analyze_program_structure()
        return self.handbook_structure
    
    def generate_chapter_content(self, module_id: str, chapter_id: str, topic_id: str = None) -> str:
        """Generuj tre≈õƒá rozdzia≈Çu/tematu u≈ºywajƒÖc AI i dostƒôpnych dokument√≥w"""
        structure = self.get_handbook_structure()
        
        # Znajd≈∫ odpowiedni element struktury
        target_item = None
        context = ""
        
        for module in structure.get('modules', []):
            if module['id'] == module_id:
                for chapter in module.get('chapters', []):
                    if chapter['id'] == chapter_id:
                        if topic_id:
                            for topic in chapter.get('topics', []):
                                if topic['id'] == topic_id:
                                    target_item = topic
                                    context = f"Modu≈Ç: {module['title']}\nRozdzia≈Ç: {chapter['title']}\nTemat: {topic['title']}"
                                    break
                        else:
                            target_item = chapter
                            context = f"Modu≈Ç: {module['title']}\nRozdzia≈Ç: {chapter['title']}"
                        break
        
        if not target_item:
            raise Exception(f"Nie znaleziono elementu: {module_id}/{chapter_id}/{topic_id}")
        
        # Znajd≈∫ powiƒÖzane dokumenty
        related_docs = self._find_related_documents(target_item['title'], target_item.get('description', ''))
        
        # Generuj tre≈õƒá u≈ºywajƒÖc AI
        try:
            system_prompt = """Jeste≈õ ekspertem lotniczym i instruktorem ATPL. Tworzysz profesjonalny podrƒôcznik szkoleniowy.
            
            Wygeneruj kompletnƒÖ tre≈õƒá dla podanego tematu w formacie markdown z nastƒôpujƒÖcymi sekcjami:
            
            # Tytu≈Ç tematu
            
            ## Wprowadzenie
            Kr√≥tkie wprowadzenie do tematu
            
            ## Cele szkoleniowe
            - Cel 1
            - Cel 2
            
            ## Teoria
            Szczeg√≥≈Çowe wyja≈õnienie teorii z przyk≈Çadami
            
            ## Procedury (je≈õli dotyczy)
            Krok po kroku procedury
            
            ## Przyk≈Çady praktyczne
            Rzeczywiste przyk≈Çady z lotnictwa
            
            ## Regulacje i przepisy
            Odno≈õne przepisy ICAO, EASA itp.
            
            ## Pytania kontrolne
            5-10 pyta≈Ñ sprawdzajƒÖcych zrozumienie
            
            ## Dodatkowe ≈∫r√≥d≈Ça
            Bibliografia i dodatkowe materia≈Çy
            
            U≈ºyj profesjonalnego jƒôzyka, dodaj diagramy w formie tekstu ASCII gdzie to mo≈ºliwe.
            Opieraj siƒô na faktach i aktualnych przepisach lotniczych."""
            
            user_prompt = f"""Kontekst: {context}
            
            Tytu≈Ç: {target_item['title']}
            Opis: {target_item.get('description', '')}
            
            PowiƒÖzane dokumenty dostƒôpne w systemie:
            {chr(10).join(related_docs[:5])}  # Maksymalnie 5 dokument√≥w
            
            Wygeneruj kompletnƒÖ tre≈õƒá szkoleniowƒÖ dla tego tematu."""
            
            response = self.client.chat.completions.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                temperature=0.4
            )
            
            content = response.choices[0].message.content
            
            # Zapisz wygenerowanƒÖ tre≈õƒá
            self._save_generated_content(module_id, chapter_id, topic_id, content)
            
            # Zaktualizuj postƒôp
            self._update_progress(module_id, chapter_id, topic_id, 'generated')
            
            return content
            
        except Exception as e:
            print(f"‚ùå B≈ÇƒÖd generowania tre≈õci: {e}")
            raise e
    
    def _find_related_documents(self, title: str, description: str) -> List[str]:
        """Znajd≈∫ dokumenty powiƒÖzane z tematem"""
        uploads_dir = 'uploads'
        if not os.path.exists(uploads_dir):
            return []
        
        related_docs = []
        search_terms = [title.lower()]
        
        # WyciƒÖgnij kluczowe s≈Çowa z opisu
        if description:
            words = re.findall(r'\b\w{4,}\b', description.lower())
            search_terms.extend(words[:10])  # Maksymalnie 10 s≈Ç√≥w kluczowych
        
        for filename in os.listdir(uploads_dir):
            if filename.endswith('.pdf'):
                filename_lower = filename.lower()
                
                # Sprawd≈∫ czy nazwa pliku zawiera kt√≥re≈õ ze s≈Ç√≥w kluczowych
                for term in search_terms:
                    if term in filename_lower:
                        related_docs.append(filename)
                        break
        
        return list(set(related_docs))  # Usu≈Ñ duplikaty
    
    def _save_generated_content(self, module_id: str, chapter_id: str, topic_id: str, content: str):
        """Zapisz wygenerowanƒÖ tre≈õƒá do pliku"""
        content_dir = os.path.join(self.handbook_dir, 'content')
        os.makedirs(content_dir, exist_ok=True)
        
        if topic_id:
            filename = f"{module_id}_{chapter_id}_{topic_id}.md"
        else:
            filename = f"{module_id}_{chapter_id}.md"
        
        filepath = os.path.join(content_dir, filename)
        
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(content)
        
        print(f"üíæ Zapisano tre≈õƒá: {filepath}")
    
    def _update_progress(self, module_id: str, chapter_id: str, topic_id: str, status: str):
        """Zaktualizuj postƒôp generowania"""
        if 'progress' not in self.handbook_structure:
            self.handbook_structure['progress'] = {}
        
        key = f"{module_id}_{chapter_id}"
        if topic_id:
            key += f"_{topic_id}"
        
        self.handbook_structure['progress'][key] = {
            'status': status,
            'updated_at': datetime.now().isoformat(),
            'module_id': module_id,
            'chapter_id': chapter_id,
            'topic_id': topic_id
        }
        
        self.save_progress()
    
    def get_progress_overview(self) -> Dict[str, Any]:
        """Pobierz przeglƒÖd postƒôpu"""
        structure = self.get_handbook_structure()
        progress = structure.get('progress', {})
        
        total_items = 0
        completed_items = 0
        
        for module in structure.get('modules', []):
            for chapter in module.get('chapters', []):
                total_items += 1
                chapter_key = f"{module['id']}_{chapter['id']}"
                if chapter_key in progress and progress[chapter_key]['status'] == 'generated':
                    completed_items += 1
                
                for topic in chapter.get('topics', []):
                    total_items += 1
                    topic_key = f"{module['id']}_{chapter['id']}_{topic['id']}"
                    if topic_key in progress and progress[topic_key]['status'] == 'generated':
                        completed_items += 1
        
        completion_percentage = (completed_items / total_items * 100) if total_items > 0 else 0
        
        return {
            'total_items': total_items,
            'completed_items': completed_items,
            'completion_percentage': round(completion_percentage, 1),
            'modules_count': len(structure.get('modules', [])),
            'last_updated': structure.get('last_updated'),
            'progress_details': progress
        }
    
    def get_content(self, module_id: str, chapter_id: str, topic_id: str = None) -> Optional[str]:
        """Pobierz wygenerowanƒÖ tre≈õƒá"""
        content_dir = os.path.join(self.handbook_dir, 'content')
        
        if topic_id:
            filename = f"{module_id}_{chapter_id}_{topic_id}.md"
        else:
            filename = f"{module_id}_{chapter_id}.md"
        
        filepath = os.path.join(content_dir, filename)
        
        if os.path.exists(filepath):
            with open(filepath, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def edit_content(self, module_id: str, chapter_id: str, topic_id: str, new_content: str):
        """Edytuj tre≈õƒá rozdzia≈Çu/tematu"""
        self._save_generated_content(module_id, chapter_id, topic_id, new_content)
        self._update_progress(module_id, chapter_id, topic_id, 'edited')
        print(f"‚úÖ Zaktualizowano tre≈õƒá: {module_id}/{chapter_id}/{topic_id}")
    
    def export_handbook(self, format_type: str = 'markdown') -> str:
        """Eksportuj ca≈Çy podrƒôcznik do jednego pliku"""
        structure = self.get_handbook_structure()
        
        if format_type == 'markdown':
            return self._export_to_markdown(structure)
        elif format_type == 'html':
            return self._export_to_html(structure)
        else:
            raise Exception(f"Nieobs≈Çugiwany format: {format_type}")
    
    def _export_to_markdown(self, structure: Dict[str, Any]) -> str:
        """Eksportuj do Markdown"""
        content = f"# {structure.get('title', 'Podrƒôcznik ATPL')}\n\n"
        content += f"{structure.get('description', '')}\n\n"
        content += f"**≈ÅƒÖczna liczba godzin:** {structure.get('total_hours', 'N/A')}\n\n"
        content += "---\n\n"
        
        for module in structure.get('modules', []):
            content += f"# {module['title']}\n\n"
            content += f"{module.get('description', '')}\n\n"
            content += f"**Godziny:** {module.get('hours', 'N/A')}\n\n"
            
            for chapter in module.get('chapters', []):
                content += f"## {chapter['title']}\n\n"
                
                # Dodaj tre≈õƒá rozdzia≈Çu je≈õli istnieje
                chapter_content = self.get_content(module['id'], chapter['id'])
                if chapter_content:
                    content += chapter_content + "\n\n"
                else:
                    content += f"{chapter.get('description', '')}\n\n"
                    content += "*Tre≈õƒá jeszcze nie zosta≈Ça wygenerowana*\n\n"
                
                for topic in chapter.get('topics', []):
                    content += f"### {topic['title']}\n\n"
                    
                    # Dodaj tre≈õƒá tematu je≈õli istnieje
                    topic_content = self.get_content(module['id'], chapter['id'], topic['id'])
                    if topic_content:
                        content += topic_content + "\n\n"
                    else:
                        content += f"{topic.get('description', '')}\n\n"
                        content += "*Tre≈õƒá jeszcze nie zosta≈Ça wygenerowana*\n\n"
        
        # Zapisz eksport
        export_dir = os.path.join(self.handbook_dir, 'exports')
        os.makedirs(export_dir, exist_ok=True)
        
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        export_path = os.path.join(export_dir, f'atpl_handbook_{timestamp}.md')
        
        with open(export_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        print(f"üìÑ Podrƒôcznik wyeksportowany: {export_path}")
        return export_path
    
    def save_progress(self):
        """Zapisz postƒôp do pliku"""
        self.handbook_structure['last_updated'] = datetime.now().isoformat()
        
        with open(self.progress_file, 'w', encoding='utf-8') as f:
            json.dump(self.handbook_structure, f, ensure_ascii=False, indent=2)
    
    def load_progress(self):
        """Za≈Çaduj postƒôp z pliku"""
        if os.path.exists(self.progress_file):
            try:
                with open(self.progress_file, 'r', encoding='utf-8') as f:
                    self.handbook_structure = json.load(f)
                print(f"üìñ Za≈Çadowano postƒôp podrƒôcznika")
            except Exception as e:
                print(f"‚ö†Ô∏è  B≈ÇƒÖd ≈Çadowania postƒôpu: {e}")
                self.handbook_structure = {}
        else:
            self.handbook_structure = {}
    
    def reset_handbook(self):
        """Resetuj ca≈Çy podrƒôcznik"""
        import shutil
        
        if os.path.exists(self.handbook_dir):
            shutil.rmtree(self.handbook_dir)
        
        os.makedirs(self.handbook_dir, exist_ok=True)
        self.handbook_structure = {}
        
        print("üîÑ Podrƒôcznik zosta≈Ç zresetowany")


# Globalna instancja generatora
_handbook_generator = None

def get_handbook_generator():
    """Pobierz globalnƒÖ instancjƒô generatora podrƒôcznika"""
    global _handbook_generator
    if _handbook_generator is None:
        _handbook_generator = ATPLHandbookGenerator()
    return _handbook_generator
