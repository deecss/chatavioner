#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Generator podrƒôcznika ATPL
Automatyczne tworzenie podrƒôcznika na podstawie dostƒôpnych dokument√≥w i AI
"""

import os
import json
import uuid
from datetime import datetime
from typing import Dict, List, Any, Optional
import PyPDF2
from .openai_rag import OpenAIRAG
import re


class ATPLHandbookGenerator:
    """Generator podrƒôcznika ATPL na podstawie dostƒôpnych dokument√≥w"""
    
    def __init__(self):
        try:
            # U≈ºyj istniejƒÖcej konfiguracji OpenAI RAG
            self.openai_rag = OpenAIRAG()
            self.client = self.openai_rag.client
        except Exception as e:
            print(f"‚ö†Ô∏è  B≈ÇƒÖd inicjalizacji OpenAI: {e}")
            self.client = None
        
        self.handbook_dir = 'handbook'
        self.program_file = None
        self.handbook_structure = {}
        self.progress_file = os.path.join(self.handbook_dir, 'progress.json')
        
        # Utw√≥rz katalog na podrƒôcznik
        os.makedirs(self.handbook_dir, exist_ok=True)
        
        # Za≈Çaduj postƒôp je≈õli istnieje
        self.load_progress()
    
    def find_program_file(self) -> Optional[str]:
        """Znajd≈∫ plik z programem ATPL"""
        uploads_dir = 'uploads'
        if not os.path.exists(uploads_dir):
            return None
        
        for filename in os.listdir(uploads_dir):
            if 'Program_ATPL-ang_serwis' in filename and filename.endswith('.pdf'):
                self.program_file = os.path.join(uploads_dir, filename)
                return self.program_file
        
        return None
    
    def extract_text_from_pdf(self, pdf_path: str) -> str:
        """WyciƒÖgnij tekst z PDF u≈ºywajƒÖc PyPDF2"""
        try:
            with open(pdf_path, 'rb') as file:
                pdf_reader = PyPDF2.PdfReader(file)
                text = ""
                
                for page in pdf_reader.pages:
                    text += page.extract_text()
                
                return text
        except Exception as e:
            print(f"‚ùå B≈ÇƒÖd wyciƒÖgania tekstu z PDF: {e}")
            return ""
    
    def analyze_program_structure(self) -> Dict[str, Any]:
        """Analizuj strukturƒô programu ATPL u≈ºywajƒÖc AI"""
        if not self.program_file:
            if not self.find_program_file():
                raise Exception("Nie znaleziono pliku z programem ATPL")
        
        print(f"üìÑ Analizujƒô strukturƒô programu: {self.program_file}")
        
        # Sprawd≈∫ dostƒôpno≈õƒá klienta OpenAI
        if not self.client:
            raise Exception("Klient OpenAI nie jest dostƒôpny. Sprawd≈∫ konfiguracjƒô OPENAI_API_KEY.")
        
        # WyciƒÖgnij tekst z PDF
        program_text = self.extract_text_from_pdf(self.program_file)
        
        if not program_text.strip():
            raise Exception("Nie uda≈Ço siƒô wyciƒÖgnƒÖƒá tekstu z pliku programu")
        
        # U≈ºyj AI do analizy struktury
        try:
            if not self.client:
                raise Exception("Klient OpenAI nie jest dostƒôpny")
            
            # Podziel tekst na mniejsze czƒô≈õci je≈õli jest za d≈Çugi
            max_chunk_size = 12000  # Bezpieczniejszy limit
            text_chunks = []
            
            if len(program_text) > max_chunk_size:
                print(f"üìã Dokument jest du≈ºy ({len(program_text)} znak√≥w), dzielƒô na czƒô≈õci...")
                for i in range(0, len(program_text), max_chunk_size):
                    chunk = program_text[i:i + max_chunk_size]
                    text_chunks.append(chunk)
            else:
                text_chunks = [program_text]
            
            print(f"üîÑ Analizujƒô {len(text_chunks)} czƒô≈õci dokumentu...")
            
            # Analizuj pierwszƒÖ czƒô≈õƒá dla g≈Ç√≥wnej struktury
            response = self.client.chat.completions.create(
                model="gpt-4o",  # U≈ºyj nowszego modelu
                messages=[
                    {
                        "role": "system",
                        "content": """Jeste≈õ ekspertem od lotnictwa i analizy dokument√≥w szkoleniowych ATPL.
                        Przeanalizuj podany tekst programu szkolenia ATPL i wyciƒÖgnij strukturƒô kursu.
                        
                        Zwr√≥ƒá odpowied≈∫ w formacie JSON z nastƒôpujƒÖcƒÖ strukturƒÖ:
                        {
                            "title": "Tytu≈Ç programu",
                            "description": "Opis programu",
                            "total_hours": "≈ÅƒÖczna liczba godzin",
                            "modules": [
                                {
                                    "id": "module_1",
                                    "title": "Tytu≈Ç modu≈Çu",
                                    "description": "Opis modu≈Çu",
                                    "hours": "Liczba godzin",
                                    "chapters": [
                                        {
                                            "id": "chapter_1_1",
                                            "title": "Tytu≈Ç rozdzia≈Çu",
                                            "description": "Opis rozdzia≈Çu",
                                            "topics": [
                                                {
                                                    "id": "topic_1_1_1",
                                                    "title": "Tytu≈Ç tematu",
                                                    "description": "Opis tematu",
                                                    "subtopics": ["podtemat 1", "podtemat 2"]
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ]
                        }
                        
                        Zachowaj wszystkie szczeg√≥≈Çy i hierarchiƒô jak w oryginalnym dokumencie.
                        U≈ºywaj polskich nazw dla czƒô≈õci po polsku i angielskich dla czƒô≈õci w jƒôzyku angielskim.
                        Skoncentruj siƒô na g≈Ç√≥wnej strukturze - modu≈Çy, rozdzia≈Çy i tematy."""
                    },
                    {
                        "role": "user",
                        "content": f"Przeanalizuj nastƒôpujƒÖcy tekst programu szkolenia ATPL (czƒô≈õƒá 1/{len(text_chunks)}):\n\n{text_chunks[0]}"
                    }
                ],
                temperature=0.3,
                timeout=60  # 60 sekund timeout
            )
            
            structure_text = response.choices[0].message.content
            print(f"üìù Otrzymano odpowied≈∫ AI ({len(structure_text)} znak√≥w)")
            
            # WyciƒÖgnij JSON z odpowiedzi
            json_match = re.search(r'\{.*\}', structure_text, re.DOTALL)
            if json_match:
                structure = json.loads(json_match.group())
            else:
                # Spr√≥buj sparsowaƒá ca≈ÇƒÖ odpowied≈∫ jako JSON
                try:
                    structure = json.loads(structure_text)
                except json.JSONDecodeError:
                    # Je≈õli nie mo≈ºna sparsowaƒá, utw√≥rz podstawowƒÖ strukturƒô
                    print("‚ö†Ô∏è  Nie mo≈ºna sparsowaƒá odpowiedzi AI, tworzƒô podstawowƒÖ strukturƒô...")
                    structure = {
                        "title": "Program Szkolenia ATPL",
                        "description": "Automatycznie wygenerowana struktura z analizy OCR",
                        "total_hours": "Nie okre≈õlono",
                        "modules": [
                            {
                                "id": "module_1",
                                "title": "Modu≈Ç 1 - Podstawy",
                                "description": "Podstawowy modu≈Ç szkoleniowy",
                                "hours": "Nie okre≈õlono",
                                "chapters": [
                                    {
                                        "id": "chapter_1_1",
                                        "title": "Rozdzia≈Ç 1.1",
                                        "description": "Wprowadzenie do tematu",
                                        "topics": [
                                            {
                                                "id": "topic_1_1_1",
                                                "title": "Temat 1.1.1",
                                                "description": "Podstawowy temat",
                                                "subtopics": ["Wprowadzenie", "Podstawy"]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ]
                    }
            
            # Sprawd≈∫ czy struktura ma wymagane pola
            if not isinstance(structure, dict) or 'modules' not in structure:
                raise Exception("AI zwr√≥ci≈Ço nieprawid≈ÇowƒÖ strukturƒô")
            
            # Dodaj ID je≈õli brakuje
            for i, module in enumerate(structure.get('modules', [])):
                if 'id' not in module:
                    module['id'] = f"module_{i+1}"
                for j, chapter in enumerate(module.get('chapters', [])):
                    if 'id' not in chapter:
                        chapter['id'] = f"chapter_{i+1}_{j+1}"
                    for k, topic in enumerate(chapter.get('topics', [])):
                        if 'id' not in topic:
                            topic['id'] = f"topic_{i+1}_{j+1}_{k+1}"
            
            # Zapisz strukturƒô
            self.handbook_structure = structure
            self.save_progress()
            
            print(f"‚úÖ Struktura programu przeanalizowana: {len(structure.get('modules', []))} modu≈Ç√≥w")
            return structure
            
        except Exception as e:
            error_msg = str(e)
            print(f"‚ùå B≈ÇƒÖd analizy struktury: {error_msg}")
            
            # Obs≈Çuga specyficznych b≈Çƒôd√≥w
            if "timed out" in error_msg.lower() or "timeout" in error_msg.lower():
                print("‚è±Ô∏è  Timeout API - spr√≥bujƒô utworzyƒá podstawowƒÖ strukturƒô z OCR...")
                
                # Utw√≥rz podstawowƒÖ strukturƒô na podstawie pierwszych linii tekstu
                lines = program_text.split('\n')[:50]  # Pierwszych 50 linii
                
                # Znajd≈∫ potencjalne tytu≈Çy (linie z du≈ºymi literami lub numerami)
                potential_titles = []
                for line in lines:
                    line = line.strip()
                    if line and (line.isupper() or re.match(r'^\d+\.', line) or re.match(r'^[IVX]+\.', line)):
                        potential_titles.append(line)
                
                structure = {
                    "title": "Program Szkolenia ATPL (OCR)",
                    "description": "Struktura utworzona automatycznie z analizy OCR po timeout API",
                    "total_hours": "Nie okre≈õlono",
                    "modules": []
                }
                
                # Utw√≥rz modu≈Çy z znalezionych tytu≈Ç√≥w
                for i, title in enumerate(potential_titles[:10]):  # Maksymalnie 10 modu≈Ç√≥w
                    module = {
                        "id": f"module_{i+1}",
                        "title": title[:100],  # Ograniczenie d≈Çugo≈õci
                        "description": f"Modu≈Ç automatycznie wyodrƒôbniony z OCR",
                        "hours": "Nie okre≈õlono",
                        "chapters": [
                            {
                                "id": f"chapter_{i+1}_1",
                                "title": f"Rozdzia≈Ç 1 - {title[:50]}",
                                "description": "Automatycznie utworzony rozdzia≈Ç",
                                "topics": [
                                    {
                                        "id": f"topic_{i+1}_1_1",
                                        "title": f"Wprowadzenie do {title[:30]}",
                                        "description": "Temat wprowadzajƒÖcy",
                                        "subtopics": ["Podstawy", "Teoria", "Praktyka"]
                                    }
                                ]
                            }
                        ]
                    }
                    structure["modules"].append(module)
                
                if not structure["modules"]:
                    # Je≈õli nie znaleziono ≈ºadnych tytu≈Ç√≥w, utw√≥rz podstawowƒÖ strukturƒô
                    structure["modules"] = [
                        {
                            "id": "module_1",
                            "title": "Modu≈Ç 1 - Podstawy ATPL",
                            "description": "Podstawowy modu≈Ç szkoleniowy",
                            "hours": "Nie okre≈õlono",
                            "chapters": [
                                {
                                    "id": "chapter_1_1",
                                    "title": "Wprowadzenie",
                                    "description": "Podstawowe informacje",
                                    "topics": [
                                        {
                                            "id": "topic_1_1_1",
                                            "title": "Podstawy lotnictwa",
                                            "description": "Fundamentalne zagadnienia",
                                            "subtopics": ["Historia", "Regulacje", "Bezpiecze≈Ñstwo"]
                                        }
                                    ]
                                }
                            ]
                        }
                    ]
                
                print(f"üìã Utworzono strukturƒô fallback z {len(structure['modules'])} modu≈Ç√≥w")
            else:
                raise e
    
    def get_handbook_structure(self) -> Dict[str, Any]:
        """Pobierz strukturƒô podrƒôcznika"""
        if not self.handbook_structure:
            return self.analyze_program_structure()
        return self.handbook_structure
    
    def generate_chapter_content(self, module_id: str, chapter_id: str = None, topic_id: str = None, ai_type: str = 'comprehensive') -> str:
        """Generuj tre≈õƒá rozdzia≈Çu/tematu u≈ºywajƒÖc AI i dostƒôpnych dokument√≥w"""
        structure = self.get_handbook_structure()
        
        # Znajd≈∫ odpowiedni element struktury
        target_item = None
        context = ""
        
        for module in structure.get('modules', []):
            if module['id'] == module_id:
                if not chapter_id:
                    # Generowanie dla modu≈Çu
                    target_item = module
                    context = f"Modu≈Ç: {module.get('title', module_id)}"
                    break
                
                for chapter in module.get('chapters', []):
                    if chapter['id'] == chapter_id:
                        if topic_id:
                            for topic in chapter.get('topics', []):
                                if topic['id'] == topic_id:
                                    target_item = topic
                                    context = f"Modu≈Ç: {module['title']}\nRozdzia≈Ç: {chapter['title']}\nTemat: {topic['title']}"
                                    break
                        else:
                            target_item = chapter
                            context = f"Modu≈Ç: {module['title']}\nRozdzia≈Ç: {chapter['title']}"
                        break
        
        if not target_item:
            if topic_id and chapter_id:
                raise Exception(f"Nie znaleziono tematu: {module_id}/{chapter_id}/{topic_id}")
            elif chapter_id:
                raise Exception(f"Nie znaleziono rozdzia≈Çu: {module_id}/{chapter_id}")
            else:
                raise Exception(f"Nie znaleziono modu≈Çu: {module_id}")
        
        # Znajd≈∫ powiƒÖzane dokumenty
        related_docs = self._find_related_documents(target_item['title'], target_item.get('description', ''))
        
        # Generuj tre≈õƒá u≈ºywajƒÖc AI z odpowiednim promptem
        try:
            system_prompt = self._get_ai_system_prompt(ai_type)
            
            user_prompt = f"""Kontekst: {context}
            
            Tytu≈Ç: {target_item['title']}
            Opis: {target_item.get('description', '')}
            
            PowiƒÖzane dokumenty dostƒôpne w systemie:
            {chr(10).join(related_docs[:5])}  # Maksymalnie 5 dokument√≥w
            
            Wygeneruj tre≈õƒá szkoleniowƒÖ zgodnie z wybranym typem."""
            
            response = self.client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                temperature=0.4
            )
            
            content = response.choices[0].message.content
            
            # Zapisz wygenerowanƒÖ tre≈õƒá
            self._save_generated_content(module_id, chapter_id, topic_id, content)
            
            # Zaktualizuj postƒôp
            self._update_progress(module_id, chapter_id, topic_id, 'generated')
            
            return content
            
        except Exception as e:
            print(f"‚ùå B≈ÇƒÖd generowania tre≈õci: {e}")
            raise e
    
    def _get_ai_system_prompt(self, ai_type: str) -> str:
        """Pobierz odpowiedni system prompt dla typu AI"""
        prompts = {
            'comprehensive': """Jeste≈õ ekspertem lotniczym i instruktorem ATPL. Tworzysz kompletny, profesjonalny podrƒôcznik szkoleniowy.
            
            Wygeneruj bardzo szczeg√≥≈ÇowƒÖ tre≈õƒá w formacie markdown z nastƒôpujƒÖcymi sekcjami:
            
            # Tytu≈Ç tematu
            
            ## üìñ Wprowadzenie
            Szczeg√≥≈Çowe wprowadzenie do tematu z kontekstem historycznym i znaczeniem w lotnictwie
            
            ## üéØ Cele szkoleniowe
            - Konkretne cele uczenia siƒô
            - Kompetencje do osiƒÖgniƒôcia
            - Standardy oceny
            
            ## üìö Teoria i podstawy
            Szczeg√≥≈Çowe wyja≈õnienie teorii z:
            - Definicjami i pojƒôciami
            - Wzorami matematycznymi (je≈õli dotyczy)
            - Diagramami ASCII
            - Przyk≈Çadami praktycznymi
            
            ## ‚öôÔ∏è Procedury
            Dok≈Çadne procedury krok po kroku z:
            - Listami kontrolnymi
            - Punktami decyzyjnymi
            - Akcjami awaryjnymi
            
            ## üõ©Ô∏è Zastosowanie w praktyce
            Rzeczywiste scenariusze lotnicze z:
            - Studiami przypadk√≥w
            - AnalizƒÖ b≈Çƒôd√≥w
            - Najlepszymi praktykami
            
            ## ‚öñÔ∏è Regulacje i przepisy
            Szczeg√≥≈Çowe przepisy z:
            - Przepisami ICAO
            - Regulacjami EASA
            - Przepisami krajowymi
            - Interpretacjami prawymi
            
            ## üîß Aspekty techniczne
            Techniczne szczeg√≥≈Çy system√≥w i urzƒÖdze≈Ñ
            
            ## ‚ùì Pytania kontrolne
            10-15 pyta≈Ñ r√≥≈ºnego typu:
            - Pytania jednokrotnego wyboru
            - Pytania wielokrotnego wyboru
            - Pytania otwarte
            - Zadania praktyczne
            
            ## üìã Listy kontrolne
            Praktyczne listy kontrolne do u≈ºycia
            
            ## üìö Bibliografia i ≈∫r√≥d≈Ça
            Kompletna lista ≈∫r√≥de≈Ç i dodatkowej literatury
            
            ## üí° Wskaz√≥wki dla instruktor√≥w
            Porady metodyczne i dydaktyczne
            
            U≈ºywaj profesjonalnego jƒôzyka lotniczego, dodawaj tabele, diagramy ASCII, przyk≈Çady oblicze≈Ñ.""",
            
            'summary': """Jeste≈õ ekspertem lotniczym tworzƒÖcym zwiƒôz≈Çe streszczenia. 
            
            Wygeneruj kondensowanƒÖ tre≈õƒá w formacie markdown:
            
            # Tytu≈Ç tematu
            
            ## üîç Kluczowe pojƒôcia
            Najwa≈ºniejsze definicje i pojƒôcia (3-5 punkt√≥w)
            
            ## ‚ö° G≈Ç√≥wne zasady
            Fundamentalne zasady i regu≈Çy (3-5 punkt√≥w)
            
            ## üìä Fakty i liczby
            Wa≈ºne parametry, limity, warto≈õci
            
            ## ‚ö†Ô∏è Kluczowe zagro≈ºenia
            G≈Ç√≥wne ryzyka i sposoby ich unikania
            
            ## üìù Pamiƒôtaj
            Lista najwa≈ºniejszych rzeczy do zapamiƒôtania
            
            ## üéØ Szybki test
            3-5 kr√≥tkich pyta≈Ñ sprawdzajƒÖcych
            
            Maksymalnie 2 strony tekstu, konkretnie i na temat.""",
            
            'practical': """Jeste≈õ instruktorem praktycznego szkolenia lotniczego.
            
            Wygeneruj tre≈õƒá skupionƒÖ na praktycznych aspektach:
            
            # Tytu≈Ç tematu
            
            ## üõ†Ô∏è Praktyczne zastosowanie
            Jak to wyglƒÖda w rzeczywisto≈õci
            
            ## üìã Procedury krok po kroku
            Szczeg√≥≈Çowe instrukcje wykonania
            
            ## üéØ Typowe scenariusze
            Prawdziwe sytuacje z kabiny pilota
            
            ## ‚ö†Ô∏è Czƒôste b≈Çƒôdy
            Co mo≈ºe p√≥j≈õƒá nie tak i jak tego unikaƒá
            
            ## üí° Wskaz√≥wki praktyczne
            Triki i rady od do≈õwiadczonych pilot√≥w
            
            ## üéÆ ƒÜwiczenia symulatorowe
            Scenariusze do treningu na symulatorze
            
            ## ‚úÖ Lista kontrolna
            Punkt po punkcie co sprawdzaƒá
            
            ## üö® Procedury awaryjne
            Co robiƒá w sytuacjach nietypowych
            
            Fokus na praktykƒô, mniej teorii, wiƒôcej dzia≈Çania.""",
            
            'regulatory': """Jeste≈õ specjalistƒÖ od przepis√≥w lotniczych.
            
            Wygeneruj tre≈õƒá skupionƒÖ na aspektach prawnych:
            
            # Tytu≈Ç tematu
            
            ## ‚öñÔ∏è Podstawa prawna
            G≈Ç√≥wne akty prawne i przepisy
            
            ## üåç Przepisy ICAO
            Miƒôdzynarodowe standardy i zalecane praktyki
            
            ## üá™üá∫ Regulacje EASA
            Europejskie przepisy wykonawcze
            
            ## üáµüá± Przepisy krajowe
            Polskie regulacje i interpretacje
            
            ## üìã Wymagania szczeg√≥≈Çowe
            Konkretne wymagania i standardy
            
            ## üìä Limity i ograniczenia
            Wszystkie parametry i ograniczenia prawne
            
            ## üìù ObowiƒÖzki i odpowiedzialno≈õƒá
            Kto za co odpowiada zgodnie z prawem
            
            ## ‚ö†Ô∏è Konsekwencje naruszenia
            Kary i sankcje za nieprzestrzeganie
            
            ## üìö ≈πr√≥d≈Ça prawne
            Dok≈Çadne odniesienia do przepis√≥w
            
            ## üîÑ Aktualizacje przepis√≥w
            Najnowsze zmiany i nowelizacje
            
            Precyzyjnie, z numerami paragraf√≥w i odniesie≈Ñ prawnych."""
        }
        
        return prompts.get(ai_type, prompts['comprehensive'])
    
    def _find_related_documents(self, title: str, description: str) -> List[str]:
        """Znajd≈∫ dokumenty powiƒÖzane z tematem"""
        uploads_dir = 'uploads'
        if not os.path.exists(uploads_dir):
            return []
        
        related_docs = []
        search_terms = [title.lower()]
        
        # WyciƒÖgnij kluczowe s≈Çowa z opisu
        if description:
            words = re.findall(r'\b\w{4,}\b', description.lower())
            search_terms.extend(words[:10])  # Maksymalnie 10 s≈Ç√≥w kluczowych
        
        for filename in os.listdir(uploads_dir):
            if filename.endswith('.pdf'):
                filename_lower = filename.lower()
                
                # Sprawd≈∫ czy nazwa pliku zawiera kt√≥re≈õ ze s≈Ç√≥w kluczowych
                for term in search_terms:
                    if term in filename_lower:
                        related_docs.append(filename)
                        break
        
        return list(set(related_docs))  # Usu≈Ñ duplikaty
    
    def _save_generated_content(self, module_id: str, chapter_id: str = None, topic_id: str = None, content: str = ''):
        """Zapisz wygenerowanƒÖ tre≈õƒá do pliku"""
        content_dir = os.path.join(self.handbook_dir, 'content')
        os.makedirs(content_dir, exist_ok=True)
        
        # Ustal nazwƒô pliku na podstawie dostƒôpnych parametr√≥w
        if topic_id and chapter_id:
            filename = f"{module_id}_{chapter_id}_{topic_id}.md"
        elif chapter_id:
            filename = f"{module_id}_{chapter_id}.md"
        else:
            filename = f"{module_id}.md"
        
        filepath = os.path.join(content_dir, filename)
        
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(content)
        
        print(f"üíæ Zapisano tre≈õƒá: {filepath}")
    
    def _update_progress(self, module_id: str, chapter_id: str = None, topic_id: str = None, status: str = 'unknown'):
        """Zaktualizuj postƒôp generowania"""
        if 'progress' not in self.handbook_structure:
            self.handbook_structure['progress'] = {}
        
        # Ustal klucz na podstawie dostƒôpnych parametr√≥w
        if topic_id and chapter_id:
            key = f"{module_id}_{chapter_id}_{topic_id}"
        elif chapter_id:
            key = f"{module_id}_{chapter_id}"
        else:
            key = f"{module_id}"
        
        self.handbook_structure['progress'][key] = {
            'status': status,
            'updated_at': datetime.now().isoformat(),
            'module_id': module_id,
            'chapter_id': chapter_id,
            'topic_id': topic_id
        }
        
        self.save_progress()
    
    def get_progress_overview(self) -> Dict[str, Any]:
        """Pobierz przeglƒÖd postƒôpu"""
        structure = self.get_handbook_structure()
        progress = structure.get('progress', {})
        
        total_items = 0
        completed_items = 0
        
        for module in structure.get('modules', []):
            for chapter in module.get('chapters', []):
                total_items += 1
                chapter_key = f"{module['id']}_{chapter['id']}"
                if chapter_key in progress and progress[chapter_key]['status'] == 'generated':
                    completed_items += 1
                
                for topic in chapter.get('topics', []):
                    total_items += 1
                    topic_key = f"{module['id']}_{chapter['id']}_{topic['id']}"
                    if topic_key in progress and progress[topic_key]['status'] == 'generated':
                        completed_items += 1
        
        completion_percentage = (completed_items / total_items * 100) if total_items > 0 else 0
        
        return {
            'total_items': total_items,
            'completed_items': completed_items,
            'completion_percentage': round(completion_percentage, 1),
            'modules_count': len(structure.get('modules', [])),
            'last_updated': structure.get('last_updated'),
            'progress_details': progress
        }
    
    def get_content(self, module_id: str, chapter_id: str = None, topic_id: str = None) -> Optional[str]:
        """Pobierz wygenerowanƒÖ tre≈õƒá"""
        content_dir = os.path.join(self.handbook_dir, 'content')
        
        if topic_id and chapter_id:
            filename = f"{module_id}_{chapter_id}_{topic_id}.md"
        elif chapter_id:
            filename = f"{module_id}_{chapter_id}.md"
        else:
            filename = f"{module_id}.md"
        
        filepath = os.path.join(content_dir, filename)
        
        if os.path.exists(filepath):
            with open(filepath, 'r', encoding='utf-8') as f:
                return f.read()
        
        return None
    
    def edit_content(self, module_id: str, chapter_id: str = None, topic_id: str = None, new_content: str = ''):
        """Edytuj tre≈õƒá rozdzia≈Çu/tematu"""
        self._save_generated_content(module_id, chapter_id, topic_id, new_content)
        self._update_progress(module_id, chapter_id, topic_id, 'edited')
        
        if topic_id and chapter_id:
            print(f"‚úÖ Zaktualizowano tre≈õƒá tematu: {module_id}/{chapter_id}/{topic_id}")
        elif chapter_id:
            print(f"‚úÖ Zaktualizowano tre≈õƒá rozdzia≈Çu: {module_id}/{chapter_id}")
        else:
            print(f"‚úÖ Zaktualizowano tre≈õƒá modu≈Çu: {module_id}")
    
    def export_handbook(self, format_type: str = 'markdown') -> str:
        """Eksportuj ca≈Çy podrƒôcznik do jednego pliku"""
        structure = self.get_handbook_structure()
        
        if format_type == 'markdown':
            return self._export_to_markdown(structure)
        elif format_type == 'html':
            return self._export_to_html(structure)
        else:
            raise Exception(f"Nieobs≈Çugiwany format: {format_type}")
    
    def _export_to_markdown(self, structure: Dict[str, Any]) -> str:
        """Eksportuj do Markdown"""
        content = f"# {structure.get('title', 'Podrƒôcznik ATPL')}\n\n"
        content += f"{structure.get('description', '')}\n\n"
        content += f"**≈ÅƒÖczna liczba godzin:** {structure.get('total_hours', 'N/A')}\n\n"
        content += "---\n\n"
        
        for module in structure.get('modules', []):
            content += f"# {module['title']}\n\n"
            content += f"{module.get('description', '')}\n\n"
            content += f"**Godziny:** {module.get('hours', 'N/A')}\n\n"
            
            for chapter in module.get('chapters', []):
                content += f"## {chapter['title']}\n\n"
                
                # Dodaj tre≈õƒá rozdzia≈Çu je≈õli istnieje
                chapter_content = self.get_content(module['id'], chapter['id'])
                if chapter_content:
                    content += chapter_content + "\n\n"
                else:
                    content += f"{chapter.get('description', '')}\n\n"
                    content += "*Tre≈õƒá jeszcze nie zosta≈Ça wygenerowana*\n\n"
                
                for topic in chapter.get('topics', []):
                    content += f"### {topic['title']}\n\n"
                    
                    # Dodaj tre≈õƒá tematu je≈õli istnieje
                    topic_content = self.get_content(module['id'], chapter['id'], topic['id'])
                    if topic_content:
                        content += topic_content + "\n\n"
                    else:
                        content += f"{topic.get('description', '')}\n\n"
                        content += "*Tre≈õƒá jeszcze nie zosta≈Ça wygenerowana*\n\n"
        
        # Zapisz eksport
        export_dir = os.path.join(self.handbook_dir, 'exports')
        os.makedirs(export_dir, exist_ok=True)
        
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        export_path = os.path.join(export_dir, f'atpl_handbook_{timestamp}.md')
        
        with open(export_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        print(f"üìÑ Podrƒôcznik wyeksportowany: {export_path}")
        return export_path
    
    def save_progress(self):
        """Zapisz postƒôp do pliku"""
        self.handbook_structure['last_updated'] = datetime.now().isoformat()
        
        with open(self.progress_file, 'w', encoding='utf-8') as f:
            json.dump(self.handbook_structure, f, ensure_ascii=False, indent=2)
    
    def load_progress(self):
        """Za≈Çaduj postƒôp z pliku"""
        if os.path.exists(self.progress_file):
            try:
                with open(self.progress_file, 'r', encoding='utf-8') as f:
                    self.handbook_structure = json.load(f)
                print(f"üìñ Za≈Çadowano postƒôp podrƒôcznika")
            except Exception as e:
                print(f"‚ö†Ô∏è  B≈ÇƒÖd ≈Çadowania postƒôpu: {e}")
                self.handbook_structure = {}
        else:
            self.handbook_structure = {}
    
    def reset_handbook(self):
        """Resetuj ca≈Çy podrƒôcznik"""
        import shutil
        
        if os.path.exists(self.handbook_dir):
            shutil.rmtree(self.handbook_dir)
        
        os.makedirs(self.handbook_dir, exist_ok=True)
        self.handbook_structure = {}
        
        print("üîÑ Podrƒôcznik zosta≈Ç zresetowany")


# Globalna instancja generatora
_handbook_generator = None

def get_handbook_generator():
    """Pobierz globalnƒÖ instancjƒô generatora podrƒôcznika"""
    global _handbook_generator
    if _handbook_generator is None:
        _handbook_generator = ATPLHandbookGenerator()
    return _handbook_generator
